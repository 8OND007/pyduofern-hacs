# mypy: ignore-errors
import asyncio
from datetime import datetime
import threading

from .duofern import Duofern as Duofern
from .exceptions import DuofernException as DuofernException, DuofernTimeoutException as DuofernTimeoutException
from _typeshed import Incomplete

def hex(stuff): ...

logger: Incomplete
duoInit1: str
duoInit2: str
duoSetDongle: str
duoInit3: str
duoSetPairs: str
duoInitEnd: str
duoACK: str
duoStatusRequest: str
duoStartPair: str
duoStopPair: str
duoStartUnpair: str
duoStopUnpair: str
duoRemotePair: str
MIN_MESSAGE_INTERVAL_MILLIS: int

def refresh_serial_connection(function): ...

class DuofernStick:
    config_file: Incomplete
    ephemeral: Incomplete
    duofern_parser: Incomplete
    running: bool
    pairing: bool
    unpairing: bool
    system_code: Incomplete
    write_queue: Incomplete
    initialized: bool
    recording: Incomplete
    def __init__(self, system_code: Incomplete | None = ..., config_file_json: Incomplete | None = ..., duofern_parser: Incomplete | None = ..., recording: Incomplete | None = ..., changes_callback: Incomplete | None = ..., ephemeral: Incomplete | None = ..., *args, **kwargs) -> None: ...
    config: Incomplete
    def prepare_config(self, config_file_json): ...
    def send(self, msg: str, **kwargs) -> None: ...
    def add_updates_callback(self, callback) -> None: ...
    def process_message(self, message) -> None: ...
    def clean_config(self) -> None: ...
    def sync_devices(self) -> None: ...
    def set_name(self, id: str, name: str) -> None: ...
    def handle_write_queue(self) -> None: ...
    def stop_pair(self) -> None: ...
    def stop_unpair(self) -> None: ...
    def pair(self, timeout: int = ...) -> None: ...
    def unpair(self, timeout: int = ...) -> None: ...
    def remote(self, code, timeout: int = ...) -> None: ...
    def test_callback(self, arg) -> None: ...

def one_time_callback(protocol, _message, name, future) -> None: ...
async def send_and_await_reply(protocol, message, message_identifier): ...

class DuofernStickAsync(DuofernStick, asyncio.Protocol):
    initialization_step: int
    loop: Incomplete
    write_queue: Incomplete
    transport: Incomplete
    buffer: Incomplete
    last_packet: float
    callback: Incomplete
    send_loop: Incomplete
    available: Incomplete
    def __init__(self, loop: Incomplete | None = ..., *args, **kwargs) -> None: ...
    def command(self, *args: str | int, **kwargs: str|int) -> None: ...
    async def add_serial_and_send(self, msg) -> None: ...
    def connection_made(self, transport) -> None: ...
    def data_received(self, data) -> None: ...
    def pause_writing(self) -> None: ...
    def resume_writing(self) -> None: ...
    def parse(self, packet) -> None: ...
    def send(self, msg: str, **kwargs) -> None: ...
    def parse_regular(self, packet) -> None: ...
    initialized: bool
    async def handshake(self) -> None: ...

class DuofernStickThreaded(DuofernStick, threading.Thread):
    port: str
    serial_connection: Incomplete
    running: bool
    last_send: datetime
    def __init__(self, serial_port: str | None = ..., *args, **kwargs) -> None: ...
    def command(self, *args, **kwargs) -> None: ...
    def add_serial_and_send(self, msg: str) -> None: ...
    def run(self) -> None: ...
    def stop(self) -> None: ...
    def pair(self, timeout: int = ...) -> None: ...
    def unpair(self, timeout: int = ...) -> None: ...
    def send(self, msg: str, **kwargs) -> None: ...
